import yaml
import os
from configparser import ConfigParser
import subprocess

def tmux_print(message):
    subprocess.run(["tmux", "display-message", message])

def load_conf():
    user_conf_path = os.path.expanduser("~/.tmux_macros.conf")
    plugin_default_conf_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "tmux_macros.conf"
    )

    conf_path = user_conf_path if os.path.exists(user_conf_path) else plugin_default_conf_path

    config = ConfigParser()
    # Use fake section header to parse ini-like key=value files
    with open(conf_path) as f:
        content = f"[default]\n" + f.read()
        config.read_string(content)

    raw_conf = dict(config.items("default"))

    # Add plugin_dir variable manually for substitution
    plugin_dir = os.path.dirname(os.path.abspath(__file__))

    def expand_vars(value):
        value = value.replace("${plugin_dir}", plugin_dir)
        return os.path.abspath(os.path.expanduser(value))

    # Expand and normalize all paths
    expanded_conf = {key: expand_vars(val) for key, val in raw_conf.items()}

    return expanded_conf

def _generate_macros_cache(cache_path, macros_dict):
    with open(cache_path, 'w') as f:
        f.write("MACROS = ")
        f.write(repr(macros_dict))


def _generate_tmux_conf(tmux_conf_file, macros, macros_py):
    with open(tmux_conf_file, 'w') as f:
        f.write("# Auto-generated by tmux-macros\n\n")
        for name, val in macros.items():
            key = None
            if isinstance(val, dict) and 'key' in val:
                key = val['key']
            if key:
                f.write(f'bind-key -n {key} run-shell "python3 {macros_py} {name}"\n')


def resolve_macros(raw_macros):
    resolved = {}

    reusable = {k: v for k, v in raw_macros.items() if k != "macros"}
    macro_definitions = raw_macros.get("macros", {})

    def expand(commands):
        result = []
        for cmd in commands:
            if isinstance(cmd, list):
                for sub in cmd:
                    result.extend(expand([sub]))
            elif isinstance(cmd, dict) and 'type' in cmd:
                result.append(cmd)
            elif isinstance(cmd, str) and cmd in reusable:
                result.extend(expand(reusable[cmd]))
            else:
                result.append(cmd)
        return result

    for name, value in macro_definitions.items():
        if isinstance(value, dict) and 'commands' in value:
            resolved[name] = {
                "commands": expand(value["commands"]),
                "key": value.get("key", None)
            }
        else:
            resolved[name] = expand(value)

    return resolved



def parse_macros_yml_and_generate_cache(conf):
    yml_file = conf['macros_yml']
    cache_file = conf['macros_cache_py']
    tmux_conf_file = conf['tmux_macros_conf']
    macros_py = conf['macros_py']

    if not os.path.exists(yml_file):
        raise FileNotFoundError(f"macros.yml not found at: {yml_file}")

    with open(yml_file, 'r') as f:
        raw_macros = yaml.safe_load(f)

    resolved_macros = resolve_macros(raw_macros)

    _generate_macros_cache(cache_file, resolved_macros)
    _generate_tmux_conf(tmux_conf_file, resolved_macros, macros_py)
    tmux_print("âœ… Cache and tmux config generated successfully.")
