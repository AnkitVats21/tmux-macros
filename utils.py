import yaml
import os
from configparser import ConfigParser

def load_conf():
    user_conf_path = os.path.expanduser("~/.tmux_macros.conf")
    plugin_default_conf_path = os.path.join(
        os.path.dirname(os.path.abspath(__file__)),
        "tmux_macros.conf"
    )

    conf_path = user_conf_path if os.path.exists(user_conf_path) else plugin_default_conf_path

    config = ConfigParser()
    # Use fake section header to parse ini-like key=value files
    with open(conf_path) as f:
        content = f"[default]\n" + f.read()
        config.read_string(content)

    raw_conf = dict(config.items("default"))

    # Add plugin_dir variable manually for substitution
    plugin_dir = os.path.dirname(os.path.abspath(__file__))

    def expand_vars(value):
        value = value.replace("${plugin_dir}", plugin_dir)
        return os.path.abspath(os.path.expanduser(value))

    # Expand and normalize all paths
    expanded_conf = {key: expand_vars(val) for key, val in raw_conf.items()}

    return expanded_conf

def expand_macros(macros_dict, shared):
    def expand(commands):
        result = []
        for item in commands:
            if isinstance(item, str) and item.startswith("*"):
                ref = item[1:]
                if ref in shared:
                    result.extend(expand(shared[ref]))
                else:
                    raise ValueError(f"Undefined macro reference: {ref}")
            else:
                result.append(item)
        return result

    for name, data in macros_dict.items():
        commands = data.get("commands", [])
        macros_dict[name]["commands"] = expand(commands)

def generate_macros(conf_path="~/.tmux_macros.conf"):
    conf = load_conf(conf_path)
    yml_file = conf.get("macros_yml", "~/.tmux/plugin/tmux-macros/macros.yml")
    cache_file = conf.get("macros_cache_py", "~/.tmux/plugin/tmux-macros/macros_cache.py")
    tmux_conf_out = conf.get("tmux_macros_conf", "~/.tmux/plugin/tmux-macros/.tmux.macros.conf")
    main_py = conf.get("macros_py", "~/.tmux/plugin/tmux-macros/macros.py")

    yml_file = os.path.expanduser(yml_file)
    cache_file = os.path.expanduser(cache_file)
    tmux_conf_out = os.path.expanduser(tmux_conf_out)
    main_py = os.path.expanduser(main_py)

    with open(yml_file, 'r') as f:
        data = yaml.safe_load(f)

    macros = data.get("macros", {})
    shared_macros = data.get("shared_macros", {})

    expand_macros(macros, shared_macros)

    # 1. Write cache file
    with open(cache_file, 'w') as f:
        f.write("MACROS = ")
        f.write(repr(macros))

    print(f"✅ Macros cache written to {cache_file}")

    # 2. Write tmux bindings
    with open(tmux_conf_out, 'w') as f:
        for name, details in macros.items():
            bind = details.get("bind")
            if bind:
                f.write(f"bind-key -n {bind} run-shell 'python3 {main_py} {name}'\n")

    print(f"✅ Tmux key bindings written to {tmux_conf_out}")



def _generate_macros_cache(cache_path, macros_dict):
    with open(cache_path, 'w') as f:
        f.write("MACROS = ")
        f.write(repr(macros_dict))


def _generate_tmux_conf(tmux_conf_file, macros, macros_py):
    with open(tmux_conf_file, 'w') as f:
        f.write("# Auto-generated by tmux-macros\n\n")
        for name, val in macros.items():
            key = None
            if isinstance(val, dict) and 'key' in val:
                key = val['key']
            if key:
                f.write(f'bind-key {key} run-shell "python3 {macros_py} {name}"\n')


def resolve_macros(raw_macros):
    resolved = {}

    reusable = {k: v for k, v in raw_macros.items() if k != "macros"}
    macro_definitions = raw_macros.get("macros", {})

    def expand(commands):
        result = []
        for cmd in commands:
            if isinstance(cmd, list):
                for sub in cmd:
                    result.extend(expand([sub]))
            elif isinstance(cmd, dict) and 'type' in cmd:
                result.append(cmd)
            elif isinstance(cmd, str) and cmd in reusable:
                result.extend(expand(reusable[cmd]))
            else:
                result.append(cmd)
        return result

    for name, value in macro_definitions.items():
        if isinstance(value, dict) and 'commands' in value:
            resolved[name] = {
                "commands": expand(value["commands"]),
                "key": value.get("key", None)
            }
        else:
            resolved[name] = expand(value)

    return resolved



def parse_macros_yml_and_generate_cache(conf):
    yml_file = conf['macros_yml']
    cache_file = conf['macros_cache_py']
    tmux_conf_file = conf['tmux_macros_conf']
    macros_py = conf['macros_py']

    if not os.path.exists(yml_file):
        raise FileNotFoundError(f"macros.yml not found at: {yml_file}")

    with open(yml_file, 'r') as f:
        raw_macros = yaml.safe_load(f)

    resolved_macros = resolve_macros(raw_macros)

    _generate_macros_cache(cache_file, resolved_macros)
    _generate_tmux_conf(tmux_conf_file, resolved_macros, macros_py)
    print("✅ Cache and tmux config generated successfully.")
